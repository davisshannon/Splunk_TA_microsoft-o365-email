{"basic_builder": {"appname": "TA_microsoft_o365_email_add_on_for_splunk", "friendly_name": "Microsoft O365 Email Add-on for Splunk", "version": "2.0.4", "author": "Splunk", "description": "Add-on for Microsoft O365 Email", "theme": "#1e88e5", "large_icon": "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", "small_icon": "iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAEtUlEQVRYR+2Xz24cRRDGf9XdM7OObeSg/DFIYMWRFQ4QIUEiIR6CB+AR8iTB55w4c+bMhSMoSkBcogQFIkIUmyj8scN61zvT3YWqx05sR7KxtLJySMnSjnd2e7766vuqakVVlVco5DWgI6rx6jGUc1JByeJBEyLuRBUVNeIIeDKKIFGzPtpIrA0z4EBOWuOCZmXxlLL0ZkC+/XWoX91zVBJptcbYOskIxpBG2mqez94dI9e+2dY2KgnFGWUnDCjhQQSvidouP/96qPODQEodWSq7TZKMqOJVSDJtvjIqrpQp2KsRoIrzge02IkvXf9dL5+e4uDhPl0aImo5CERiYrqYbdn62hEVK0hDxruHh0y3urg2R5dV1HU8y5+YdH60s4K1ouf9CX8YpR3aIGEuKSsA4uv3gb9Y3InNNjaysrukkKdFKJMLVC3OcWWjQ2ILWJZtphvEumnBVxT//ttz8ZZNWHcEJjUTk4upj7RJkNdMrbYblMzUfLJ0mx5bkwSVQr0iuTGHHwmcMJ9chqULF4woY4c6jTe7/EWm8CUNwApWJ+iCg7CBnz4xPfPLeaRa8smViT4qTSD5m41QRQnJ0LlNLYpI83/38F8NWsKOc6uGAxGVyrvGS2cqJD995g5Wzji56souIhmMxZCUypzZ14uFT+OHBBqdETMo416Em8sMYMthW4yyCw9HGyLn5hiuXFvApkor7/n8UUzjPj/ef8ejZmEHwfaczZpzD5Xw4IOsR+8P6BJjnrq6cZnHWMcyBYGLPCWwG7ol+8ihJPI2LbI4z39/bYOyEutzZf77oMQGZ0O2vk755Lp+f5eO3KyY7VJeb+wBFsquZcXBnbcTd9SHBD4r+JBvzBxM4JiBRK1EkiLWGQKcds3NzfHphrgg/HugKEoQUlZu/jflzc0TjXZlVqCeZlQ6U/NgM2ReiC1TaolSE2QHZ1+TU8f5izdJ8oOu6wlFVVTweRn5a78DXVLmjG22huQUaVNqXTHE0oD0ltnXbOnfOgmsaZGam7EwW1sljjJydC1xZlPL/7Sfw5FlLCIHnq7qVaHubPNlGSnfuBV10KVIuD3VZGWUmiyJkihOq2VnUW4OSctMeZof1ZrEP99dlU9jzfplX1m5FkZTotka4lMraZWHVtmcdbvsiUim2D1VNGAyIJTPBlcG8H4w3bdH3Jq+xHL4fLKhpR5WgQp5MaNtJAV9wHQWorLPeEwYzSFX1D8g2+3MRpYHaG0ZQv0NJKcfBLmWLqS8VsilPGRGSInE8gmjlt5NfGh2G3tPZnGoG1IOGpH29bWmbZuxszmWQt5MJjLcIBJIolRdk5Ys1HeWMwxNmG5yvyCXtnYynvNE+Z1EpoHKMxNE2WSMzBmj5+pq2dcWgmcEU8EL9PZJdPUyLpV339Q7rE7etaDLZou465NKNDZ34sLMc2kLZA5l2qXYT2jXFi7ZgrnWIF5qYkMtfbupGrKm0K1Cy+f4EwznbsyLJ1ZyybeLGrS1dvbXLjLloyqI5IjknCVWhdRXXLivSpU5vPxEeb3b9jjtdUx3JdcqKd8L5WcfVt6yB5mztqvyQBV+Uf5Jh7iq9ru/79kvkhGt0RLavAR0lh1eOof8AgSzhar3gYnQAAAAASUVORK5CYII=", "visible": true, "tab_version": "3.0.1", "tab_build_no": "2", "build_no": 49}, "data_input_builder": {"datainputs": [{"index": "default", "sourcetype": "ms:o365:email", "interval": "300", "use_external_validation": true, "streaming_mode_xml": true, "name": "o365_email", "title": "O365 Email", "description": "", "type": "customized", "parameters": [{"name": "audit_email_account", "label": "Audit Email Account", "help_string": "Please enter the audit email configured in the O365 mail flow rule", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "mail@williamshannondavis.onmicrosoft.com"}, {"name": "inbox_id", "label": "Inbox ID", "help_string": "Go to https://developer.microsoft.com/en-us/graph/graph-explorer, log in as the audit email account, and run https://graph.microsoft.com/v1.0/me/mailFolders.  Copy the id value for the Inbox folder.", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "AQMkADg3NjQyNmQyLTg0NTgtNDc1Zi04YjkzLWU4YWEAMjRjNWFiZjMALgAAA2fLqKp2axtEsRbzLllObh4BACjeNSCNXdJJl1nfhXgjjSoAAAIBDAAAAA=="}, {"name": "tenant", "label": "Tenant ID", "help_string": "Please enter the Tenant ID from the Azure App registration process", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "13f33e79-eae7-4716-8d3f-d6b03f0e3ea0"}, {"name": "endpoint", "label": "Endpoint", "help_string": "", "required": true, "possible_values": [{"value": "worldwide", "label": "Worldwide"}, {"value": "gcchigh", "label": "USGovGCCHigh"}], "format_type": "dropdownlist", "default_value": "worldwide", "placeholder": "", "type": "dropdownlist", "value": "worldwide"}, {"name": "get_attachment_info", "label": "Get Attachment Info", "help_string": "Gathers basic attachment info (name, type, size, hash, etc).", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": true}, {"name": "read_zip_files", "label": "Read Zip Files", "help_string": "Attempts to read file names and file hashes from within zip files.  Requires Get Attachment Info to be selected.", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": true}, {"name": "file_hash_algorithm", "label": "File Hash Algorithm", "help_string": "Used for attachment and zip file hashing.", "required": false, "possible_values": [{"value": "md5", "label": "MD5"}, {"value": "sha1", "label": "SHA1"}, {"value": "sha256", "label": "SHA256"}], "format_type": "dropdownlist", "default_value": "md5", "placeholder": "", "type": "dropdownlist", "value": "sha1"}, {"name": "extract_iocs", "label": "Extract IOCs", "help_string": "Attempts to extract IOCs from supported attachment types (currently HTML, PDF, XML, CSV) and email bodies.  (URLs, domains, ipv4, ipv6, hashes, etc).", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": true}, {"name": "macro_analysis", "label": "Macro Analysis", "help_string": "Detects and analyses macros within Office document formats.", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": true}, {"name": "attachment_data_ingest", "label": "Attachment Data Ingest", "help_string": "Will attempt to ingest the actual data from the attachment.  WARNING- POTENTIALLY LARGE INGEST IF ENABLED.  Can also take more time if the files are large.", "required": false, "possible_values": [{"value": "html", "label": "HTML"}, {"value": "xml", "label": "XML"}, {"value": "pdf", "label": "PDF"}, {"label": "CSV", "value": "csv"}], "format_type": "multi_dropdownlist", "default_value": [], "placeholder": "", "type": "multi_dropdownlist", "value": ["html", "xml", "pdf", "csv"]}, {"name": "get_body", "label": "Get Body", "help_string": "Retrieves the whole message body for emails and any emails that are attached.\n\nWARNING- POTENTIALLY LARGE INGEST IF ENABLED", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": true}, {"name": "get_body_preview", "label": "Get Body Preview", "help_string": "Only retrieves the first 255 characters in the email body", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": true}, {"name": "get_message_path", "label": "Get Message Path", "help_string": "Gathers all MTA hops the message traversed", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": true}, {"name": "get_internet_headers", "label": "Get Internet Headers", "help_string": "Retrieves All Internet Headers", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": true}, {"name": "get_auth_results", "label": "Get Auth Results", "help_string": "Gathers authentication results headers", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": true}, {"name": "get_spf_results", "label": "Get SPF Results", "help_string": "Gathers SPF results from the headers", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": true}, {"name": "get_dkim_signature", "label": "Get DKIM Signature", "help_string": "Gathers DKIM signature results from the headers", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": true}, {"name": "get_x_headers", "label": "Get X Headers", "help_string": "Gathers all X-Headers from the headers", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": true}, {"name": "global_account", "label": "Global Account", "help_string": "", "required": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": "", "type": "global_account", "value": "account0"}], "data_inputs_options": [{"type": "customized_var", "name": "audit_email_account", "title": "Audit Email Account", "description": "Please enter the audit email configured in the O365 mail flow rule", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "inbox_id", "title": "Inbox ID", "description": "Go to https://developer.microsoft.com/en-us/graph/graph-explorer, log in as the audit email account, and run https://graph.microsoft.com/v1.0/me/mailFolders.  Copy the id value for the Inbox folder.", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "tenant", "title": "Tenant ID", "description": "Please enter the Tenant ID from the Azure App registration process", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "endpoint", "title": "Endpoint", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [{"value": "worldwide", "label": "Worldwide"}, {"value": "gcchigh", "label": "USGovGCCHigh"}], "format_type": "dropdownlist", "default_value": "worldwide", "placeholder": ""}, {"type": "customized_var", "name": "get_attachment_info", "title": "Get Attachment Info", "description": "Gathers basic attachment info (name, type, size, hash, etc).", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}, {"type": "customized_var", "name": "read_zip_files", "title": "Read Zip Files", "description": "Attempts to read file names and file hashes from within zip files.  Requires Get Attachment Info to be selected.", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}, {"type": "customized_var", "name": "file_hash_algorithm", "title": "File Hash Algorithm", "description": "Used for attachment and zip file hashing.", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": "md5", "label": "MD5"}, {"value": "sha1", "label": "SHA1"}, {"value": "sha256", "label": "SHA256"}], "format_type": "dropdownlist", "default_value": "md5", "placeholder": ""}, {"type": "customized_var", "name": "extract_iocs", "title": "Extract IOCs", "description": "Attempts to extract IOCs from supported attachment types (currently HTML, PDF, XML, CSV) and email bodies.  (URLs, domains, ipv4, ipv6, hashes, etc).", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}, {"type": "customized_var", "name": "macro_analysis", "title": "Macro Analysis", "description": "Detects and analyses macros within Office document formats.", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}, {"type": "customized_var", "name": "attachment_data_ingest", "title": "Attachment Data Ingest", "description": "Will attempt to ingest the actual data from the attachment.  WARNING- POTENTIALLY LARGE INGEST IF ENABLED.  Can also take more time if the files are large.", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": "html", "label": "HTML"}, {"value": "xml", "label": "XML"}, {"value": "pdf", "label": "PDF"}, {"label": "CSV", "value": "csv"}], "format_type": "multi_dropdownlist", "default_value": [], "placeholder": ""}, {"type": "customized_var", "name": "get_body", "title": "Get Body", "description": "Retrieves the whole message body for emails and any emails that are attached.\n\nWARNING- POTENTIALLY LARGE INGEST IF ENABLED", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}, {"type": "customized_var", "name": "get_body_preview", "title": "Get Body Preview", "description": "Only retrieves the first 255 characters in the email body", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}, {"type": "customized_var", "name": "get_message_path", "title": "Get Message Path", "description": "Gathers all MTA hops the message traversed", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}, {"type": "customized_var", "name": "get_internet_headers", "title": "Get Internet Headers", "description": "Retrieves All Internet Headers", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}, {"type": "customized_var", "name": "get_auth_results", "title": "Get Auth Results", "description": "Gathers authentication results headers", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}, {"type": "customized_var", "name": "get_spf_results", "title": "Get SPF Results", "description": "Gathers SPF results from the headers", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}, {"type": "customized_var", "name": "get_dkim_signature", "title": "Get DKIM Signature", "description": "Gathers DKIM signature results from the headers", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}, {"type": "customized_var", "name": "get_x_headers", "title": "Get X Headers", "description": "Gathers all X-Headers from the headers", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}, {"type": "customized_var", "name": "global_account", "title": "Global Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}], "code": "# encoding = utf-8\n\nimport json\nimport datetime\nimport splunk.entity\nimport urllib\nimport sys\nimport hashlib\nimport base64\nimport re\nimport email\nimport html\nimport io\nimport cryptography\nimport csv\nimport itertools\n#from email.parser import BytesParser\nfrom oletools.olevba import VBA_Parser, VBA_Scanner\nfrom bs4 import BeautifulSoup\nfrom pdfminer.converter import TextConverter\nfrom pdfminer.layout import LAParams\nfrom pdfminer.pdfdocument import PDFDocument\nfrom pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter\nfrom pdfminer.pdfpage import PDFPage\nfrom pdfminer.pdfparser import PDFParser\nfrom io import StringIO\nfrom zipfile import ZipFile\n\n\nACCESS_TOKEN = 'access_token'\nCURRENT_TOKEN = None\nLOG_DIRECTORY_NAME = 'logs'\nTIME_FORMAT = '%Y-%m-%dT%H:%M:%S.000Z'\n\n#Regex statements used in IOC extraction routines.\nurl_re = re.compile(r'(http|ftp|https|ftps|scp):\\/\\/([\\w_-]+(?:(?:\\.[\\w_-]+)+))([\\w.,@?^=%&:\\/~+#-;]*[\\w@?^=%&\\/~+#-])?')\ndomain_re = re.compile(r'\\b((?=[a-z0-9-]{1,63}\\.)(xn--)?[a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,63}\\b')\nipv4_re = re.compile(r'((?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)')\nipv6_re = re.compile(r'\\b(?:[a-f0-9]{1,4}:|:){2,7}(?:[a-f0-9]{1,4}|:)\\b')\n\n#Setting minimum interval in TA to 60 seconds\ndef validate_input(helper, definition):\n    interval_in_seconds = int(definition.parameters.get('interval'))\n    if interval_in_seconds < 60:\n        raise ValueError(\"field 'Interval' should be at least 60\")\n    filter_arg = definition.parameters.get('filter')\n    if filter_arg is not None and 'lastModifiedDateTime' in filter_arg:\n        raise ValueError(\"'lastModifiedDateTime' is a reserved property and cannot be part of the filter\")\n\n#Obtain access token via oauth2\ndef _get_access_token(helper):\n    \n    if helper.get_arg('endpoint') == 'worldwide':\n        login_url = 'https://login.microsoftonline.com/'\n        graph_url = 'https://graph.microsoft.com/'\n    elif helper.get_arg('endpoint') == 'gcchigh':\n        login_url = 'https://login.microsoftonline.us/'\n        graph_url = 'https://graph.microsoft.us/'\n        \n    global CURRENT_TOKEN\n    if CURRENT_TOKEN is None:\n        _data = {\n            'client_id': helper.get_arg('global_account')['username'],\n            'scope': graph_url + '.default',\n            'client_secret': helper.get_arg('global_account')['password'],\n            'grant_type': 'client_credentials',\n            'Content-Type': 'application/x-www-form-urlencoded'\n            }\n        _url = login_url + helper.get_arg('tenant') + '/oauth2/v2.0/token'\n        if (sys.version_info > (3, 0)):\n            access_token = helper.send_http_request(_url, \"POST\", payload=urllib.parse.urlencode(_data), timeout=(15.0, 15.0)).json()\n        else:\n            access_token = helper.send_http_request(_url, \"POST\", payload=urllib.urlencode(_data), timeout=(15.0, 15.0)).json()\n\n        CURRENT_TOKEN = access_token[ACCESS_TOKEN]\n        return access_token[ACCESS_TOKEN]\n\n    else:\n        return CURRENT_TOKEN\n\n#Returning version of TA\ndef _get_app_version(helper):\n    app_version = \"\"\n    if 'session_key' in helper.context_meta:\n        session_key = helper.context_meta[\"session_key\"]\n        entity = splunk.entity.getEntity('/configs/conf-app','launcher', namespace=helper.get_app_name(), sessionKey=session_key, owner='nobody')\n        app_version = entity.get('version')\n    return app_version\n\n#Function to write events to Splunk\ndef _write_events(helper, ew, messages=None):\n    if messages:\n        for message in messages:\n            event = helper.new_event(\n                source=helper.get_input_type(),\n                index=helper.get_output_index(),\n                sourcetype=helper.get_sourcetype(),\n                data=json.dumps(message))\n            ew.write_event(event)\n\n#Purging of messages after ingest to Splunk.  This is using the recoverableitemspurges folder, which emulates a hard delete.\ndef _purge_messages(helper, messages):\n    \n    if helper.get_arg('endpoint') == 'worldwide':\n        graph_url = 'https://graph.microsoft.com/v1.0'\n    elif helper.get_arg('endpoint') == 'gcchigh':\n        graph_url = 'https://graph.microsoft.us/v1.0'\n        \n    access_token = _get_access_token(helper)\n\n    headers = {\"Authorization\": \"Bearer \" + access_token,\n                \"Content-type\": \"application/json\"}\n    _data = {\n            \"destinationId\": \"recoverableitemspurges\"\n            }\n\n    for message in messages:\n        for item in message:\n            response = helper.send_http_request(graph_url + \"/users/\" + helper.get_arg('audit_email_account') + \"/messages/\" + item[\"id\"] + \"/move\", \"POST\", headers=headers, payload=_data, timeout\n=(15.0, 15.0))\n\n#Top level IOC extraction from various items (email bodies, supported file types, etc).  Currently only attempting URLS, domains, and IP address (v4 and v6). Calls URL, Domain, and IP address functions below.\ndef extract_iocs(helper, data):\n    return itertools.chain(\n        extract_urls(data),\n        extract_domains(data),\n        extract_ips(data)\n    )\n\n#URL IOC extraction function.\ndef extract_urls(data):\n    urls = itertools.chain(\n        url_re.finditer(data)\n    )\n    for url in urls:\n        url = url.group(0)\n        yield url\n\n#Domain IOC extraction function.\ndef extract_domains(data):\n    domains = itertools.chain(\n        domain_re.finditer(data)\n    )\n    for domain in domains:\n        domain = domain.group(0)\n        yield domain\n\n#Top level IP address IOC extraction function. Calls IPv4 and IPv6 functions below.\ndef extract_ips(data):\n    return itertools.chain(\n        extract_ipv4(data),\n        extract_ipv6(data)\n    )\n\n#IPv4 IOC extraction function.\ndef extract_ipv4(data):\n    ipv4s = itertools.chain(\n        ipv4_re.finditer(data)\n    )\n    for ip in ipv4s:\n        ip = ip.group(0)\n        yield ip\n\n#IPv6 IOC extraction function.\ndef extract_ipv6(data):\n    ipv6s = itertools.chain(\n        ipv6_re.finditer(data)\n    )\n    for ip in ipv6s:\n        ip = ip.group(0)\n        yield ip\n\n#Main function for gathering emails.\ndef collect_events(helper, ew):\n    \n    if helper.get_arg('endpoint') == 'worldwide':\n        graph_url = 'https://graph.microsoft.com/v1.0'\n    elif helper.get_arg('endpoint') == 'gcchigh':\n        graph_url = 'https://graph.microsoft.us/v1.0'\n        \n    access_token = _get_access_token(helper)\n\n    headers = {\"Authorization\": \"Bearer \" + access_token,\n                \"User-Agent\": \"MicrosoftGraphEmail-Splunk/\" + _get_app_version(helper),\n                \"Prefer\": \"outlook.body-content-type=text\"}\n\n    interval_in_seconds = int(helper.get_arg('interval'))\n\n    endpoint = \"/users/\" + helper.get_arg('audit_email_account')\n    endpoint += \"/mailFolders/\" + helper.get_arg('inbox_id') + \"/messages/?$expand=SingleValueExtendedProperties($filter=Id eq 'LONG 0x0E08'),attachments\"\n        \n    endpoint += \"&$select=subject,sender,from,hasAttachments,internetMessageId,toRecipients,ccRecipients,bccRecipients,replyTo,internetMessageHeaders,body,bodyPreview&$top=999\"\n\n    messages_response = helper.send_http_request(graph_url + endpoint, \"GET\", headers=headers, parameters=None, timeout=(15.0, 15.0)).json()\n    \n    messages = []\n    \n    #Routine that iterates through the messages.  Uses the @odata.nextLink values to find the next endpoint to query.\n    \n    messages.append(messages_response['value'])\n    \n    url_count = 1\n    \n    while \"@odata.nextLink\" in messages_response:\n        if url_count < 1000:\n              nextlinkurl = messages_response[\"@odata.nextLink\"]\n              messages_response = helper.send_http_request(nextlinkurl, \"GET\", headers=headers, parameters=None, timeout=(15.0, 15.0)).json()\n              messages.append(messages_response['value'])\n              url_count += 1\n        else:\n            helper.log_debug(\"Loop detecting, breaking out\")\n            break\n\n    #Routine to find attachments in messages.  This caters for both standard, as well as inline attachments.  MS Graph doesn't list inline attachments in the \"hasAttachments\" value, this fixes that.\n    message_data = []\n    \n    for message in messages:\n        \n        message_items = {}\n        \n        for item in message:\n            \n            message_items['to'] = item['toRecipients']\n            message_items['from'] = item['from']\n            message_items['sender'] = item['sender']\n            message_items['subject'] = item['subject']\n            message_items['id'] = item['id']\n            message_items['ccRecipients'] = item['ccRecipients']\n            message_items['bccRecipients'] = item['bccRecipients']\n            message_items['replyTo'] = item['replyTo']\n            message_items['hasAttachments'] = item['hasAttachments']\n            \n            message_body = item['body']['content']\n            body_preview = item['bodyPreview']\n            attachments = item['attachments']\n            internet_message_headers = item['internetMessageHeaders']\n            single_value_properties = item['singleValueExtendedProperties']\n            \n            #message path calculations\n            message_path = []\n            path_item = {}\n            \n            for item in internet_message_headers:\n                if item['name'] == \"Received\":\n                    path_item=item\n                    message_path.append(path_item)\n            \n            src_line = str(message_path[-1])\n            dest_line = str(message_path[0])\n            \n            re_by = re.compile(r'(?<=\\bby\\s)(\\S+)')\n            re_from = re.compile(r'(?<=\\bfrom\\s)(\\S+)')\n            \n            dest = re_by.search(dest_line)\n            \n            if re_from.search(src_line):\n                src = re_from.search(src_line)\n            elif re_by.search(src_line):\n                src = re_by.search(src_line)\n            \n            message_items['src'] = str(src[0])    \n            message_items['dest'] = str(dest[0])\n            \n            #size mapping\n            for item in single_value_properties:\n                if item['id'] == \"Long 0xe08\":\n                    message_items['size'] = item['value']\n                    \n            if helper.get_arg('get_body'):\n                message_items['body'] = message_body\n            \n            if helper.get_arg('get_body_preview'):\n                message_items['bodyPreview'] = body_preview\n            \n            if helper.get_arg('get_internet_headers'):\n                message_items['Internet-Headers'] = internet_message_headers\n            \n            if helper.get_arg('get_attachment_info'):\n                message_items['attachments'] = attachments\n                \n            if helper.get_arg('get_message_path'):\n                message_items['message_path'] = message_path\n            \n            if helper.get_arg('get_x_headers'):\n                \n                x_headers = []\n                x_header_item = {}\n                \n                for item in internet_message_headers:\n                    if \"X-\" in item['name']:\n                        x_header_item=item\n                        x_headers.append(x_header_item)\n                        \n                message_items['X-Headers'] = x_headers\n             \n            if helper.get_arg('get_auth_results'):\n                \n                auth_results = []\n                auth_results_item = {}\n                \n                for item in internet_message_headers:\n                    if \"Authentication-Results\" in item['name']:\n                        auth_results_item=item\n                        auth_results.append(auth_results_item)\n                        \n                message_items['Authentication-Results'] = auth_results\n            \n            if helper.get_arg('get_spf_results'):\n                \n                spf_results = []\n                spf_results_item = {}\n                \n                for item in internet_message_headers:\n                    if \"Received-SPF\" in item['name']:\n                        spf_results_item=item\n                        spf_results.append(spf_results_item)\n                        \n                message_items['Received-SPF'] = spf_results\n            \n            if helper.get_arg('get_dkim_signature'):\n                \n                dkim_sig = []\n                dkim_sig_item = {}\n                \n                for item in internet_message_headers:\n                    if \"DKIM-Signature\" in item['name']:\n                        dkim_sig_item=item\n                        dkim_sig.append(dkim_sig_item)\n                        \n                message_items['DKIM-Signature'] = dkim_sig\n                \n            message_data.append(message_items)\n            \n            if helper.get_arg('get_body'):\n                if helper.get_arg('extract_iocs'):\n\n                    iocs = extract_iocs(helper, message_items[\"body\"])\n\n                    email_iocs = []\n\n                    for ioc in iocs:\n                        if not ioc in email_iocs:\n                            email_iocs.append(ioc)\n                    if email_iocs:\n                        message_items['iocs'] = email_iocs\n                        \n            if helper.get_arg('get_attachment_info'):\n\n                if message_items['attachments'] is not None:\n\n                    attach_data = []\n\n                    for attachment in message_items[\"attachments\"]:\n\n                        #Looks for itemAttachment type, which is a contact, event, or message that's attached.\n                        if attachment[\"@odata.type\"] == \"#microsoft.graph.itemAttachment\":\n\n                            my_added_data = {}\n                            \n                            my_added_data['name'] = attachment['name']\n                            my_added_data['odata_type'] = attachment['@odata.type']\n                            my_added_data['id'] = attachment['id']\n                            my_added_data['contentType'] = attachment['contentType']\n                            my_added_data['size'] = attachment['size']\n\n                            attach_data.append(my_added_data)\n                        \n                        #Looks for referenceAttachment type, which is a link to a file on OneDrive or other supported storage location\n                        if attachment[\"@odata.type\"] == \"#microsoft.graph.referenceAttachment\":\n\n                            my_added_data = {}\n\n                            my_added_data['name'] = attachment['name']\n                            my_added_data['odata_type'] = attachment['@odata.type']\n                            my_added_data['id'] = attachment['id']\n                            my_added_data['contentType'] = attachment['contentType']\n                            my_added_data['size'] = attachment['size']\n\n                            attach_data.append(my_added_data)\n                        \n                        #Looks for fileAttachment type, which is a standard email attachment.\n                        if attachment[\"@odata.type\"] == \"#microsoft.graph.fileAttachment\":\n\n                            my_added_data = {}\n\n                            attach_b64decode = base64.b64decode(attachment['contentBytes'])\n\n                            #Selects which hashing algorithm (md5, sha1, sha256) to use on the attachment.\n                            if helper.get_arg('get_attachment_info') and helper.get_arg('file_hash_algorithm') == 'md5':\n                                hash_object = hashlib.md5(attach_b64decode)\n                            if helper.get_arg('get_attachment_info') and helper.get_arg('file_hash_algorithm') == 'sha1':\n                                hash_object = hashlib.sha1(attach_b64decode)\n                            if helper.get_arg('get_attachment_info') and helper.get_arg('file_hash_algorithm') == 'sha256':\n                                hash_object = hashlib.sha256(attach_b64decode)\n\n                            att_hash = hash_object.hexdigest()\n\n                            my_added_data['name'] = attachment['name']\n                            my_added_data['odata_type'] = attachment['@odata.type']\n                            my_added_data['id'] = attachment['id']\n                            my_added_data['contentType'] = attachment['contentType']\n                            my_added_data['size'] = attachment['size']\n                            my_added_data['file_hash'] = att_hash\n                        \n                            #Attempts to open up zip file to list file names and hashes if the option is selected in the input.\n                            if helper.get_arg('get_attachment_info') and helper.get_arg('read_zip_files') and attachment['@odata.mediaContentType'] == 'application/zip':\n\n                                filedata_encoded = attachment['contentBytes'].encode()\n                                file_bytes = base64.b64decode(filedata_encoded)\n\n                                zipbytes = io.BytesIO(file_bytes)\n                            \n                                try:\n                                    zipfile = ZipFile(zipbytes)\n                                \n                                    zipmembers = zipfile.namelist()\n                                \n                                    zip_files = []\n                                    zip_hashes = []\n                                \n                                    for file in zipmembers:\n                                   \n                                        zip_read = zipfile.read(file)\n                                    \n                                        if helper.get_arg('file_hash_algorithm') == 'md5':\n                                            hash_object = hashlib.md5(zip_read)\n                                        if helper.get_arg('file_hash_algorithm') == 'sha1':\n                                            hash_object = hashlib.sha1(zip_read)\n                                        if helper.get_arg('file_hash_algorithm') == 'sha256':\n                                            hash_object = hashlib.sha256(zip_read)    \n                                        \n                                        zip_hash = hash_object.hexdigest()\n                                    \n                                        if not file in zip_files:\n                                        \n                                            zip_files.append(file)\n                                            zip_hashes.append(zip_hash)\n\n                                        if zip_files:\n                                            my_added_data['zip_files'] = zip_files\n                                            my_added_data['zip_hashes'] = zip_hashes\n                                        \n                                except:\n                                    my_added_data['attention'] = 'could not extract the zip file, may be encrypted'\n                                \n                                \n                            #Routine to gather info on CSV file types.\n                            if helper.get_arg('get_attachment_info') and attachment['@odata.mediaContentType'] == 'text/csv':\n\n                                filedata_encoded = attachment['contentBytes'].encode()\n                                file_bytes = base64.b64decode(filedata_encoded)\n\n                                csvbytes = io.BytesIO(file_bytes)\n                            \n                                try:\n                                    csvstring = csvbytes.read().decode('utf-8')\n\n                                    if helper.get_arg('extract_iocs'):\n\n                                        iocs = extract_iocs(helper, csvstring)\n\n                                        csv_iocs = []\n\n                                        for ioc in iocs:\n                                            if not ioc in csv_iocs:\n                                                csv_iocs.append(ioc)\n                                        if csv_iocs:\n                                            my_added_data['iocs'] = csv_iocs\n\n                                    #Will attempt to ingest the actual contents of the CSV file if this option is selected in the input.\n                                    if 'csv' in helper.get_arg('attachment_data_ingest'):\n                                        my_added_data['csv_data'] = csvstring\n                                    \n                                except:\n                                    my_added_data['attention'] = 'could not parse the csv document, may be encrypted'\n                                \n\n                            #Routine to gather info on HTML file types.\n                            if helper.get_arg('get_attachment_info') and attachment['@odata.mediaContentType'] == 'text/html':\n\n                                filedata_encoded = attachment['contentBytes'].encode()\n                                file_bytes = base64.b64decode(filedata_encoded)\n\n                                try:\n                                    uncooked_soup = html.unescape(str(file_bytes))\n\n                                    soup = BeautifulSoup(uncooked_soup)\n\n                                    soup_data = str(soup)\n\n                                    if helper.get_arg('extract_iocs'):\n\n                                        iocs = extract_iocs(helper, soup_data)\n\n                                        html_iocs = []\n\n                                        for ioc in iocs:\n                                            if not ioc in html_iocs:\n                                                html_iocs.append(ioc)\n                                        if html_iocs:\n                                            my_added_data['iocs'] = html_iocs\n\n                                    #Will attempt to ingest the actual contents of the HTML file if this option is selected in the input.\n                                    if 'html' in helper.get_arg('attachment_data_ingest'):\n                                        my_added_data['html_data'] = soup_data\n                                    \n                                except:\n                                    my_added_data['attention'] = 'could not parse the html document, may be encrypted'\n\n\n                            #Routine to gather info on PDF file types.\n                            if helper.get_arg('get_attachment_info') and attachment['@odata.mediaContentType'] == 'application/pdf':\n\n                                filedata_encoded = attachment['contentBytes'].encode()\n\n                                file_bytes = base64.b64decode(filedata_encoded)\n\n                                pdf_content = io.BytesIO(file_bytes)\n\n                                output_string = StringIO()\n\n                                try:\n                                    parser = PDFParser(pdf_content)\n                                \n                                    doc = PDFDocument(parser)\n\n                                    rsrcmgr = PDFResourceManager()\n\n                                    device = TextConverter(rsrcmgr, output_string, laparams=LAParams())\n\n                                    interpreter = PDFPageInterpreter(rsrcmgr, device)\n\n                                    for page in PDFPage.create_pages(doc):\n                                        interpreter.process_page(page)\n\n                                    pdf_text = output_string.getvalue()\n                                \n                                    if helper.get_arg('extract_iocs'):\n\n                                        iocs = extract_iocs(helper, pdf_text)\n\n                                        pdf_iocs = []\n\n                                        for ioc in iocs:\n                                            if not ioc in pdf_iocs:\n                                                pdf_iocs.append(ioc)\n                                            if pdf_iocs:\n                                                my_added_data['iocs'] = pdf_iocs\n\n                                    #Will attempt to ingest the actual contents of the PDF file if this option is selected in the input.\n                                    if 'pdf' in helper.get_arg('attachment_data_ingest'):\n                                        my_added_data['pdf_data'] = pdf_text\n                                \n                                except:\n                                    my_added_data['attention'] = 'could not parse the pdf document, may be encrypted'\n\n\n                            #Routine to gather info on XML file types.\n                            if helper.get_arg('get_attachment_info') and attachment['@odata.mediaContentType'] == 'text/xml':\n\n                                filedata_encoded = attachment['contentBytes'].encode()\n\n                                file_bytes = base64.b64decode(filedata_encoded)\n\n                                try:\n                                    soup = BeautifulSoup(file_bytes, 'lxml')\n\n                                    soup_data = str(soup)\n\n                                    if helper.get_arg('extract_iocs'):\n\n                                        iocs = extract_iocs(helper, soup_data)\n\n                                        xml_iocs = []\n\n                                        for ioc in iocs:\n                                            if not ioc in xml_iocs:\n                                                xml_iocs.append(ioc)\n                                        if xml_iocs:\n                                            my_added_data['iocs'] = xml_iocs\n\n                                    #Will attempt to ingest the actual contents of the XML file if this option is selected in the input.\n                                    if 'xml' in helper.get_arg('attachment_data_ingest'):\n                                        my_added_data['xml_data'] = soup_data\n                                    \n                                except:\n                                    my_added_data['attention'] = 'could not parse the xml document, may be encrypted'\n                                \n\n                            #Routine to do macro analysis on files of supported content types listed below if selected in the input setup.  This uses OLEVBA tools to detect macros in the attachment, then analyses the macros.\n                            if helper.get_arg('get_attachment_info') and helper.get_arg('macro_analysis'):\n\n                                filename = attachment['name']\n\n                                #Content types supported by OLEVBA.\n                                supported_content = ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n                                'application/vnd.openxmlformats-officedocument.spreadsheetml.template',\n                                'application/vnd.ms-excel.sheet.macroenabled.12',\n                                'application/vnd.ms-excel.template.macroenabled.12',\n                                'application/vnd.ms-excel.addin.macroenabled.12',\n                                'application/vnd.ms-excel.sheet.binary.macroenabled.12',\n                                'application/vnd.ms-excel',\n                                'application/xml',\n                                'application/vnd.ms-powerpoint',\n                                'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n                                'application/vnd.openxmlformats-officedocument.presentationml.template',\n                                'application/vnd.openxmlformats-officedocument.presentationml.slideshow',\n                                'application/vnd.ms-powerpoint.addin.macroenabled.12',\n                                'application/vnd.ms-powerpoint.presentation.macroenabled.12',\n                                'application/vnd.ms-powerpoint.template.macroenabled.12',\n                                'application/vnd.ms-powerpoint.slideshow.macroenabled.12',\n                                'application/msword',\n                                'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                                'application/vnd.openxmlformats-officedocument.wordprocessingml.template',\n                                'application/vnd.ms-word.document.macroenabled.12',\n                                'application/vnd.ms-word.template.macroenabled.12']\n\n                                if attachment['@odata.mediaContentType'] in supported_content:\n\n                                    filedata_encoded = attachment['contentBytes'].encode()\n                                    file_bytes = base64.b64decode(filedata_encoded)\n\n                                    try:\n                                        vbaparser = VBA_Parser(filename, data=file_bytes)\n\n                                        if vbaparser.detect_vba_macros():\n                                            my_added_data['macros_exist'] = \"true\"\n\n                                            macro_analysis = VBA_Parser.analyze_macros(vbaparser)\n                                            helper.log_debug(\"GET Response: \" + json.dumps(macro_analysis, indent=4))\n\n                                            if macro_analysis == []:\n                                                my_added_data['macro_analysis'] = \"Macro doesn't look bad, but I never trust macros.\"\n                                            else:\n                                                my_added_data['macros_analysis'] = macro_analysis\n\n                                        else:\n                                            my_added_data['macros_exist'] = \"false\"\n                                        \n                                    except:\n                                        my_added_data['attention'] = 'could not extract the office document, may be encrypted'\n\n                            attach_data.append(my_added_data)\n\n            message_items['attachments'] = attach_data\n        \n        _write_events(helper, ew, messages=message_data)\n    _purge_messages(helper, messages)\n", "customized_options": [{"name": "audit_email_account", "value": "mail@williamshannondavis.onmicrosoft.com"}, {"name": "inbox_id", "value": "AQMkADg3NjQyNmQyLTg0NTgtNDc1Zi04YjkzLWU4YWEAMjRjNWFiZjMALgAAA2fLqKp2axtEsRbzLllObh4BACjeNSCNXdJJl1nfhXgjjSoAAAIBDAAAAA=="}, {"name": "tenant", "value": "13f33e79-eae7-4716-8d3f-d6b03f0e3ea0"}, {"name": "endpoint", "value": "worldwide"}, {"name": "get_attachment_info", "value": true}, {"name": "read_zip_files", "value": true}, {"name": "file_hash_algorithm", "value": "sha1"}, {"name": "extract_iocs", "value": true}, {"name": "macro_analysis", "value": true}, {"name": "attachment_data_ingest", "value": ["html", "xml", "pdf", "csv"]}, {"name": "get_body", "value": true}, {"name": "get_body_preview", "value": true}, {"name": "get_message_path", "value": true}, {"name": "get_internet_headers", "value": true}, {"name": "get_auth_results", "value": true}, {"name": "get_spf_results", "value": true}, {"name": "get_dkim_signature", "value": true}, {"name": "get_x_headers", "value": true}, {"name": "global_account", "value": "account0"}], "uuid": "9d4229bdf5284f64b0c392d52c9db5b4", "sample_count": "891"}]}, "field_extraction_builder": {"ms:o365:email": {"data_format": "json"}}, "global_settings_builder": {"global_settings": {"proxy_settings": {"proxy_type": "http"}, "log_settings": {"log_level": "DEBUG"}, "credential_settings": []}}, "sourcetype_builder": {"ms:o365:email": {"metadata": {"event_count": 0, "data_input_name": "o365_email", "extractions_count": 0, "cims_count": 0}}}, "validation": {"validators": ["best_practice_validation", "data_model_mapping_validation", "field_extract_validation", "app_cert_validation"], "status": "job_finished", "validation_id": "v_1608337086_22", "progress": 1.0}}